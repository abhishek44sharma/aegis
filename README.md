```text
 .-'_.---._'-.
 ||####|(__)||   Protect your secrets, protect your business.
   \\()|##//       Secure your sensitive data with Aegis.
    \\ |#//                  <aegis.z2h.dev>
     .\_/.
```

![Aegis](assets/aegis-banner.png "Aegis")

## Status of This Software

**Work In Progress**.

This project is a work in progress.

Stay tuned. More to come.

## About Aegis

**Aegis** is a comprehensive secrets management solution that helps you keep 
your secrets secret. With **Aegis**, you can rest assured that your sensitive 
data is **secure** and **protected** at all times. 

With its industry-standard encryption capabilities, **Aegis** ensures that your 
secrets are only accessible to authorized users, helping you safeguard your 
business and protect against data breaches.

## Project Folder Structure

// note: `k create ns aegis-system` first.

// TODO: this is a monorepo; explain how it works.

// TODO: explain the project’s folder structure.


// k exec -it aegis-sentinel-6558cbd5f9-7ddw9 -n aegis-system -- /bin/zsh

// TODO: comparison with vault.
// much less moving parts
// much simpler 
// very little footprint
// perfect for storing arbitrary configuration info
// future plans include cloud KMS integration thanks to Mozilla sops.
// simple api
// extremely small attack surface.

// TODO: talk about constraints as in:
// * This is a Kubernetes-first Cloud Native project
// * will start with a minimal API set.
// * Initially, the configuration and integration options will be limited.
// * There will be a timeline and a list of features that will be added.
// * There will be a place to provide feedback and request more features.

// TODO: talk about system requirements; where Aegis is tested and how.

// TODO: Right now, there is only a single person behind this thing (yours truly)
// that has its advantages (as me being the benevolent dictator) but also 
// limitations (I work on Aegis on my **persona** time).

// TODO: to docs: using a `todo.txt` format to track issues, as this is 
// the fastest way to bootsrap a project. Will continue to do text-base
// issue management until the project is either mature enough, or I start feeling
// some pain. — maybe I won’t need to use GitHub issues “ever”, not sure.

// TODO: NotaryId and SafeID will typically be generated by CI.
// TOOD: maybe write a generator script to generate all needed yamls.

// Bootstrap process: exchange safe (but known) token with a more secure unknown
// and randomly-generated token.
// after bootstrapping, workloads use workload id and workload secret
// after bootstrapping, notary uses (again a randomly-generated) notary token 
// for interaction with safe. 

pasting more random stuff to be organized.

```text
# `notary` -> `safe`

# “Hey `safe`, I am `notary`, here is my id (that you already know)
# and here is the workload token that we will share from this point on when
# communicating with workloads. I will also deliver you workload ids and
# workload secrets. The workloads will identify themselves with those ids
# and secrets.”
# “Ah, by the way, this is the admin token, figure out a way to securely
# dispatch it to the admins. You can store it at say /opt/aegis/admin.token
# for now; and later down the line create mini cli app that will display the
# token only once for the admin to store safely.”


# TODO: probably we need an “unregister” API too.

# `notary` -> `safe`

# The workload API is used by `notary` to register a workload to `safe`.
# `safe` will not dispatch secrets to a workload if it is not registered.
#  `workloadId` and `workloadToken` are generated by `notary`.

# `admin` -> `safe`

# Keep the admin token safe; do not store it in source control.
# An ideal place to store it is a password manager or an encrypted file.
# Admin retrieves secure admin token via a secure means after `notary`
# bootstraps `safe`.


# `workload` -> `safe`

# `SecureWorkloadToken` has been shared with the workload by `notary`.
# This shall deliver the token that admin has created for this workload.

//reqres "aegis-sidecar/internal/entity/reqres/v1"
//"aegis-sidecar/internal/state"
//"bytes"
//"context"
//"encoding/json"
//"github.com/go-kit/kit/endpoint"
//"github.com/go-kit/kit/transport/http"
//"io"
//nhttp "net/http"
//"net/url"

//name := p.ObjectMeta.Name
//namespace := p.ObjectMeta.Namespace
//uid := p.ObjectMeta.UID
//// aegis-workload-key: aegis-workload-demo
//workloadKey, ok := p.Annotations["aegis-workload-key"]
//
//fmt.Println("added a pod")

kubectl port-forward aegis-workload-demo-6d7858c7bd-l2nh7 8039:8039 -n default
kubectl port-forward aegis-safe-5ff46447d8-hf89n 8017:8017 -n aegis system

```


## Design Documents

Note that this part is highly work-in-progress. Everything is under **a lot** of
flux right now.

### Aegis High-Level Architecture

![Aegis](assets/aegis-hla.png "Aegis High-Level Architecture")

### Bootstrapping

![Bootstrapping](assets/notary-state-handshake.png "Bootstrapping")

### Sequence Diagram

![Sequence Diagram](assets/sequence-diagram.png "Aegis High-Level Architecture")
